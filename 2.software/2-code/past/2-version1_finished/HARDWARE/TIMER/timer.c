#include "timer.h"
#include "mylvgl.h"
#include "beep.h"
#include "rtc.h"
#include "can.h"

//////////////////////////////////////////////////////////////////////////////////	 
//本程序只供学习使用，未经作者许可，不得用于其它任何用途
//ALIENTEK STM32F407开发板
//定时器 驱动代码	   
//正点原子@ALIENTEK
//技术论坛:www.openedv.com
//创建日期:2014/5/4
//版本：V1.0
//版权所有，盗版必究。
//Copyright(C) 广州市星翼电子科技有限公司 2014-2024
//All rights reserved									  
////////////////////////////////////////////////////////////////////////////////// 	 


//通用定时器3中断初始化
//arr：自动重装值。
//psc：时钟预分频数
//定时器溢出时间计算方法:Tout=((arr+1)*(psc+1))/Ft us.
//Ft=定时器工作频率,单位:Mhz
//这里使用的是定时器3!
void TIM3_Int_Init(u16 arr,u16 psc)
{
	TIM_TimeBaseInitTypeDef TIM_TimeBaseInitStructure;
	NVIC_InitTypeDef NVIC_InitStructure;
	
	RCC_APB1PeriphClockCmd(RCC_APB1Periph_TIM3,ENABLE);  ///使能TIM3时钟
	
  TIM_TimeBaseInitStructure.TIM_Period = arr; 	//自动重装载值
	TIM_TimeBaseInitStructure.TIM_Prescaler=psc;  //定时器分频
	TIM_TimeBaseInitStructure.TIM_CounterMode=TIM_CounterMode_Up; //向上计数模式
	TIM_TimeBaseInitStructure.TIM_ClockDivision=TIM_CKD_DIV1; 
	
	TIM_TimeBaseInit(TIM3,&TIM_TimeBaseInitStructure);//初始化TIM3
	
	TIM_ITConfig(TIM3,TIM_IT_Update,ENABLE); //允许定时器3更新中断
	TIM_Cmd(TIM3,ENABLE); //使能定时器3
	
	NVIC_InitStructure.NVIC_IRQChannel=TIM3_IRQn; //定时器3中断
	NVIC_InitStructure.NVIC_IRQChannelPreemptionPriority=0x01; //抢占优先级1
	NVIC_InitStructure.NVIC_IRQChannelSubPriority=0x03; //子优先级3
	NVIC_InitStructure.NVIC_IRQChannelCmd=ENABLE;
	NVIC_Init(&NVIC_InitStructure);
	
}
//定时器3中断服务函数
void TIM3_IRQHandler(void)
{
	if(TIM_GetITStatus(TIM3,TIM_IT_Update)==SET) //溢出中断
	{
		//屏幕心跳
		lv_tick_inc(1);

		//触摸按钮的beep
		if(my_lv_obj.btn_beep_sound_flag)
		{
			my_lv_obj.btn_beep_sound_time++;
			if(my_lv_obj.btn_beep_sound_time>50) 
			{
				my_lv_obj.btn_beep_sound_time = 0;
				BEEP_sound(0);
			}
		}	
		my_lv_obj.time_timer_count++;
//		static int count = 0;
//		if(my_lv_obj.time_timer_count % 60 == 0) {
//			count++;
//			if(count == 4) count = 0;
//		}
//		switch(count)
//		{
//			case 0:
//			case 1:
//				enable_TPDO(ADDRESS_5801_1, TPDO1, TPDOCOMMAND_YES);
//				enable_TPDO(ADDRESS_5801_1, TPDO2, TPDOCOMMAND_YES);
//				enable_TPDO(ADDRESS_5801_1, TPDO3, TPDOCOMMAND_YES);
//				enable_TPDO(ADDRESS_5801_1, TPDO4, TPDOCOMMAND_YES);
//				enable_TPDO(ADDRESS_5801_2, TPDO1, TPDOCOMMAND_NO);
//				enable_TPDO(ADDRESS_5801_2, TPDO4, TPDOCOMMAND_NO);
//				enable_TPDO(ADDRESS_7017, TPDO1, TPDOCOMMAND_NO);
//				enable_TPDO(ADDRESS_7017, TPDO2, TPDOCOMMAND_NO);	
//				break;
//			case 2:
//				enable_TPDO(ADDRESS_5801_1, TPDO1, TPDOCOMMAND_NO);
//				enable_TPDO(ADDRESS_5801_1, TPDO2, TPDOCOMMAND_NO);
//				enable_TPDO(ADDRESS_5801_1, TPDO3, TPDOCOMMAND_NO);
//				enable_TPDO(ADDRESS_5801_1, TPDO4, TPDOCOMMAND_NO);
//				enable_TPDO(ADDRESS_5801_2, TPDO1, TPDOCOMMAND_YES);
//				enable_TPDO(ADDRESS_5801_2, TPDO4, TPDOCOMMAND_YES);
//				enable_TPDO(ADDRESS_7017, TPDO1, TPDOCOMMAND_NO);
//				enable_TPDO(ADDRESS_7017, TPDO2, TPDOCOMMAND_NO);
//				break;
//			case 3:
//				enable_TPDO(ADDRESS_5801_1, TPDO1, TPDOCOMMAND_NO);
//				enable_TPDO(ADDRESS_5801_1, TPDO2, TPDOCOMMAND_NO);
//				enable_TPDO(ADDRESS_5801_1, TPDO3, TPDOCOMMAND_NO);
//				enable_TPDO(ADDRESS_5801_1, TPDO4, TPDOCOMMAND_NO);
//				enable_TPDO(ADDRESS_5801_2, TPDO1, TPDOCOMMAND_NO);
//				enable_TPDO(ADDRESS_5801_2, TPDO4, TPDOCOMMAND_NO);
//				enable_TPDO(ADDRESS_7017, TPDO1, TPDOCOMMAND_YES);
//				enable_TPDO(ADDRESS_7017, TPDO2, TPDOCOMMAND_YES);
//				break;
//		}
		if(my_lv_obj.win_sys3_motor1_ena_switch_flag == WIN_SYS3_SWITCH_OPEN && my_lv_obj.time_timer_count % my_lv_obj.win_sys3_motor1_speed_slider_value == 0 )
		{
			static u8 flag = 0;
			if(flag == 0) 
				my_lv_obj.win_sys3_motor_value = my_lv_obj.win_sys3_motor_value & 0xFB;//11111011
			else if(flag == 1)
				my_lv_obj.win_sys3_motor_value = my_lv_obj.win_sys3_motor_value | 0x04;//00000100
			Set_4055_Switchoutput(ADDRESS_4055, my_lv_obj.win_sys3_motor_value);
			flag = !flag;
		}
		if(my_lv_obj.win_sys3_motor2_ena_switch_flag == WIN_SYS3_SWITCH_OPEN && my_lv_obj.time_timer_count % my_lv_obj.win_sys3_motor2_speed_slider_value == 0 )
		{
			static u8 flag = 0;
			if(flag == 0) 
				my_lv_obj.win_sys3_motor_value = my_lv_obj.win_sys3_motor_value & 0x7F;//01111111
			else if(flag == 1)
				my_lv_obj.win_sys3_motor_value = my_lv_obj.win_sys3_motor_value | 0x80;//10000000
			Set_4055_Switchoutput(ADDRESS_4055, my_lv_obj.win_sys3_motor_value);
			flag = !flag;
		}
		//溢出清零
		if(my_lv_obj.time_timer_count == 10000) my_lv_obj.time_timer_count = 0;
	}
	TIM_ClearITPendingBit(TIM3,TIM_IT_Update);  //清除中断标志位
}
